#pragma config(Motor,  port2,           rollerMotor,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           leftMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           releaseMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Sensor, in1,    frontDistanceSensor,        sensorAnalog)
#pragma config(Sensor, in2,    backDistanceSensor,        sensorAnalog)
#pragma config(Sensor, in3,    enemyDistanceSensor,        sensorAnalog)
#pragma config(Sensor, in4,    angledDistanceSensor,        sensorAnalog)
#pragma config(Sensor, dgtl1, pickUpSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl2, backLeftSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl3, frontRightSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl4, frontLeftSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl5, backRightSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl7,  northSensor,      sensorDigitalIn)
#pragma config(Sensor, dgtl8,  eastSensor,      sensorDigitalIn)
#pragma config(Sensor, dgtl9,  southSensor,      sensorDigitalIn)
#pragma config(Sensor, dgtl10,  westSensor,      sensorDigitalIn)
#pragma config(Sensor, dgtl11, rampSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl6, backLeftBumperSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl12, backRightBumperSensor, sensorDigitalIn)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int frontDistance;
int backDistance;
int enemyDistance;
int angledDistance;
int ramp = 1;
int pickUp = 1;
int backLeft;
int frontRight;
int frontLeft;
int backRight;
int north;
int east;
int south;
int west;
int freshRun = 1;
int backLeftBumper;
int backRightBumper;

void releaseBall() {
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	motor[releaseMotor] = -60;
	wait1Msec(1250);
	while (pickUp == 0){
		pickUp = SensorValue[pickUpSensor];
		motor[releaseMotor] = 0;
	}
	motor[releaseMotor] = 60;
	wait1Msec(1250);
	motor[releaseMotor] = 0;
}

void moveForward(int speed) {
	motor[leftMotor] = -speed - 5;
	motor[rightMotor] = speed;
}

void moveBackward(int speed) {
	motor[leftMotor] = speed + 5;
	motor[rightMotor] = -speed;
	clearTimer(T2);
}

void rotateAntiClockwise(int speed) {
	motor[leftMotor] = speed;
	motor[rightMotor] = speed;
	clearTimer(T2);
}

void rotateClockwise(int speed) {
	motor[leftMotor] = -speed;
	motor[rightMotor] = -speed;
	clearTimer(T2);
}

void stopMovement() {
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	clearTimer(T2);
}

void reorient(int speed) {
	north = SensorValue(northSensor);
	east = SensorValue(eastSensor);
	west = SensorValue(westSensor);
	south = SensorValue(southSensor);
	if (((north == 1) && (east == 1)  && (south == 0) && (west == 1))
		|| ((north == 1) && (east == 0)  && (south == 0) && (west == 1))
		|| ((north == 1) && (east == 0)  && (south == 1) && (west == 1))
		|| ((north == 0) && (east == 0)  && (south == 1) && (west == 1))) {
		while (true) {
			north = SensorValue(northSensor);
			east = SensorValue(eastSensor);
			west = SensorValue(westSensor);
			south = SensorValue(southSensor);
			if ((north == 1) && (east == 1)  && (south == 0) && (west == 0)) {
				break;
			}
			else {
				rotateClockwise(speed);
			}
		}
		//moveBackward(60);
		stopMovement();
	}
	else {
		while (true) {
			north = SensorValue(northSensor);
			east = SensorValue(eastSensor);
			west = SensorValue(westSensor);
			south = SensorValue(southSensor);
			if ((north == 1) && (east == 1)  && (south == 0) && (west == 1)) {
				break;
			}
			else {
				rotateAntiClockwise(speed);
			}
		}
		//moveBackward(60);
		stopMovement();
	}
}

void reorientLeft(int speed) {
	north = SensorValue(northSensor);
	east = SensorValue(eastSensor);
	west = SensorValue(westSensor);
	south = SensorValue(southSensor);
	if (((north == 1) && (east == 0)  && (south == 1) && (west == 1))
		|| ((north == 0) && (east == 0)  && (south == 1) && (west == 1))) {
		while (true) {
			north = SensorValue(northSensor);
			east = SensorValue(eastSensor);
			west = SensorValue(westSensor);
			south = SensorValue(southSensor);
			if ((north == 1) && (east == 0)  && (south == 1) && (west == 1)) {
			rotateClockwise(speed);
			wait1Msec(1);

				stopMovement();
				break;
			}
			else {
				rotateClockwise(speed);
			}
		}
	}
    else {
		while (true) {
			north = SensorValue(northSensor);
			east = SensorValue(eastSensor);
			west = SensorValue(westSensor);
			south = SensorValue(southSensor);
			if ((north == 1) && (east == 0)  && (south == 1) && (west == 1)) {
				;
				stopMovement();
				break;
			}
			else {
				rotateAntiClockwise(speed);
			}
		}

	}
}

bool isRunning = false;
bool lastBumperState = false;
bool firstRun = True;

task main() {
	while (true) {
		bool currentBumperState = (SensorValue[backLeftBumperSensor] == 0); // pressed = 0

		// Toggle state when bumper is pressed
		if (currentBumperState && !lastBumperState) {
			isRunning = !isRunning;  // Toggle between true and false
			wait1Msec(200);          // Debounce delay
		}
		lastBumperState = currentBumperState;
		if (isRunning) {
			// Run your robot's logic here
			if (firstRun){



			///////////////////////////////////////////////////////main code////////////////////
			while (true){
				frontDistance = SensorValue(frontDistanceSensor);
		backDistance = SensorValue(backDistanceSensor);
		enemyDistance = SensorValue(enemyDistanceSensor);
		angledDistance = SensorValue(angledDistanceSensor);
		backLeft = SensorValue(backLeftSensor);
		frontRight = SensorValue(frontRightSensor);
		frontLeft = SensorValue(frontLeftSensor);
		backRight = SensorValue(backRightSensor);

		//Convert analog value to distance(m)
		if (frontDistance > 200) {
			frontDistance = 1 / ((frontDistance + 149.1) / 24339);
		}
		else {
			frontDistance = 100.0;
		}

		//Convert analog value to distance(m)
		if (angledDistance > 200) {
			angledDistance = 1 / ((angledDistance + 149.1) / 24339);
		}
		else {
			angledDistance = 100.0;
		}

		if (enemyDistance > 200) {
			enemyDistance = 1 / ((enemyDistance + 149.1) / 24339);
		}
		else {
			enemyDistance = 100.0;
		}
				writeDebugStreamLine("front: %d", frontDistance);
				writeDebugStreamLine("angle: %d", angledDistance);\
				clearDebugStream();

			}














				//////////////////////////////////////////////////main code END///////////////////////////////////


				//use below code for one time run codes
				firstRun= false;
		}
		} else {
			stopMovement();
			firstRun = True;
		}

		wait1Msec(20); // Small delay to prevent tight loop
	}
}
