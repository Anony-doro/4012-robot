#pragma config(Motor,  port2,           rollerMotor,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           leftMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           releaseMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Sensor, in1,    frontDistanceSensor,        sensorAnalog)
#pragma config(Sensor, in2,    backDistanceSensor,        sensorAnalog)
#pragma config(Sensor, in3,    enemyDistanceSensor,        sensorAnalog)
#pragma config(Sensor, in4,    angledDistanceSensor,        sensorAnalog)
#pragma config(Sensor, dgtl1, pickUpSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl2, backLeftSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl3, frontRightSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl4, frontLeftSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl5, backRightSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl7,  northSensor,      sensorDigitalIn)
#pragma config(Sensor, dgtl8,  eastSensor,      sensorDigitalIn)
#pragma config(Sensor, dgtl9,  southSensor,      sensorDigitalIn)
#pragma config(Sensor, dgtl10,  westSensor,      sensorDigitalIn)
#pragma config(Sensor, dgtl11, rampSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl6, backLeftBumperSensor, sensorDigitalIn)
#pragma config(Sensor, dgtl12, backRightBumperSensor, sensorDigitalIn)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int frontDistance;
int backDistance;
int enemyDistance;
int angledDistance;
int ramp = 1;
int pickUp = 1;
int backLeft;
int frontRight;
int frontLeft;
int backRight;
int north;
int east;
int south;
int west;
int freshRun = 1;
int backLeftBumper;
int backRightBumper;

void releaseBall() {
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	motor[releaseMotor] = -60;
	wait1Msec(1250);
	while (pickUp == 0){
		pickUp = SensorValue[pickUpSensor];
		motor[releaseMotor] = 0;
	}
	motor[releaseMotor] = 60;
	wait1Msec(1250);
	motor[releaseMotor] = 0;
}

void moveForward(int speed) {
	motor[leftMotor] = -speed - 5;
	motor[rightMotor] = speed;
}

void moveBackward(int speed) {
	motor[leftMotor] = speed + 5;
	motor[rightMotor] = -speed;
	clearTimer(T2);
}

void rotateAntiClockwise(int speed) {
	motor[leftMotor] = speed;
	motor[rightMotor] = speed;
	clearTimer(T2);
}

void rotateClockwise(int speed) {
	motor[leftMotor] = -speed;
	motor[rightMotor] = -speed;
	clearTimer(T2);
}

void stopMovement() {
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	clearTimer(T2);
}

void reorient(int speed) {
	north = SensorValue(northSensor);
	east = SensorValue(eastSensor);
	west = SensorValue(westSensor);
	south = SensorValue(southSensor);
	if (((north == 1) && (east == 1)  && (south == 0) && (west == 1))
		|| ((north == 1) && (east == 0)  && (south == 0) && (west == 1))) {
		while (true) {
			north = SensorValue(northSensor);
			east = SensorValue(eastSensor);
			west = SensorValue(westSensor);
			south = SensorValue(southSensor);
			if ((north == 1) && (east == 1)  && (south == 0) && (west == 1)) {
			rotateClockwise(speed);
			wait1Msec(1);
			//moveBackward(60);
			stopMovement();
				break;
			}
			else {
				rotateClockwise(speed);
			}
		}
	}
	else {
		while (true) {
			north = SensorValue(northSensor);
			east = SensorValue(eastSensor);
			west = SensorValue(westSensor);
			south = SensorValue(southSensor);
			if ((north == 1) && (east == 1)  && (south == 0) && (west == 1)) {
				//moveBackward(60);
				stopMovement();
				break;
			}
			else {
				rotateAntiClockwise(speed);
			}
		}
	}
}

void reorientLeft(int speed) {
	north = SensorValue(northSensor);
	east = SensorValue(eastSensor);
	west = SensorValue(westSensor);
	south = SensorValue(southSensor);
	if (((north == 1) && (east == 0)  && (south == 1) && (west == 1))
		|| ((north == 0) && (east == 0)  && (south == 1) && (west == 1))) {
		while (true) {
			north = SensorValue(northSensor);
			east = SensorValue(eastSensor);
			west = SensorValue(westSensor);
			south = SensorValue(southSensor);
			if ((north == 1) && (east == 0)  && (south == 1) && (west == 1)) {
			rotateClockwise(speed);
			wait1Msec(1);

				stopMovement();
				break;
			}
			else {
				rotateClockwise(speed);
			}
		}
	}
    else {
		while (true) {
			north = SensorValue(northSensor);
			east = SensorValue(eastSensor);
			west = SensorValue(westSensor);
			south = SensorValue(southSensor);
			if ((north == 1) && (east == 0)  && (south == 1) && (west == 1)) {
				;
				stopMovement();
				break;
			}
			else {
				rotateAntiClockwise(speed);
			}
		}

	}
}

bool isRunning = false;
bool lastBumperState = false;
bool firstRun = True;

task main() {
	while (true) {
		bool currentBumperState = (SensorValue[backLeftBumperSensor] == 0); // pressed = 0

		// Toggle state when bumper is pressed
		if (currentBumperState && !lastBumperState) {
			isRunning = !isRunning;  // Toggle between true and false
			wait1Msec(200);          // Debounce delay
		}
		lastBumperState = currentBumperState;
		if (isRunning) {
			// Run your robot's logic here
			if (firstRun){



			///////////////////////////////////////////////////////main code////////////////////
				reorient(45);














				//////////////////////////////////////////////////main code END///////////////////////////////////


				//use below code for one time run codes
				firstRun= false;
		}
		} else {
			stopMovement();
			firstRun = True;
		}

		wait1Msec(20); // Small delay to prevent tight loop
	}
}
